<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Flow - Video Player</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="styles.css">
    <style>
        .video-container {
            position: relative;
            padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
            height: 0;
            overflow: hidden;
            margin-bottom: 20px;
            background: #000;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 12px;
        }

        /* Make sure the player container is hidden until the video loads */
        #player {
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        #player.loaded {
            opacity: 1;
        }

        /* Recording controls styles */
        .recording-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            margin-bottom: 20px;
        }

        .recording-controls button {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .recording-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .recording-controls button i {
            margin-right: 5px;
        }

        /* Audio player styles */
        audio {
            width: 100%;
            height: 36px;
            margin-top: 8px;
            border-radius: 8px;
            background-color: rgba(var(--primary-rgb), 0.1);
        }

        audio::-webkit-media-controls-panel {
            background-color: rgba(var(--primary-rgb), 0.1);
        }

        audio::-webkit-media-controls-current-time-display,
        audio::-webkit-media-controls-time-remaining-display {
            color: var(--text-color);
        }

        /* Note item styles for voice notes */
        .note-item {
            background: rgba(var(--primary-rgb), 0.05);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
            transition: transform 0.3s ease;
        }

        .note-item:hover {
            transform: translateX(5px);
        }

        .note-timestamp {
            font-size: 0.9rem;
            color: var(--primary-color);
            cursor: pointer;
            margin-bottom: 5px;
        }

        .note-text {
            margin-bottom: 8px;
        }

        .note-delete {
            color: var(--danger-color);
            cursor: pointer;
            float: right;
            margin-top: 5px;
        }

        /* Watch history styles */
        .watch-history-item {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 10px;
            transition: transform 0.2s;
        }
        
        .watch-history-item:hover {
            transform: translateX(5px);
        }
        
        .watch-history-thumbnail {
            width: 80px;
            height: 45px;
            object-fit: cover;
            border-radius: 4px;
        }
        
        .watch-history-info {
            max-width: calc(100% - 120px);
        }
        
        .watch-history-info h6 {
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #notesList {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 8px;
            margin-right: -8px;
            scrollbar-width: thin;
        }

        #notesList::-webkit-scrollbar {
            width: 6px;
        }

        #notesList::-webkit-scrollbar-track {
            background: var(--card-bg);
            border-radius: 10px;
        }

        #notesList::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 10px;
        }

        #notesList::-webkit-scrollbar-thumb:hover {
            background: var(--primary-hover-color);
        }

        .note-actions {
            opacity: 1;
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .note-item {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: transform 0.2s ease;
        }

        .note-item:hover {
            transform: translateX(5px);
        }

        .note-text {
            color: var(--text-color);
            font-size: 1rem;
            line-height: 1.5;
            margin: 8px 0;
            word-wrap: break-word;
        }

        .note-timestamp {
            font-size: 0.9rem;
            color: var(--primary-color);
            font-weight: 500;
            cursor: pointer;
            margin-bottom: 5px;
        }

        .edit-note-form {
            background: var(--card-bg);
            padding: 10px;
            border-radius: 8px;
            margin-top: 8px;
            border: 1px solid var(--border-color);
        }

        .edit-note-form textarea {
            background: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            width: 100%;
            padding: 8px;
            resize: vertical;
            min-height: 60px;
        }

        .edit-note-form textarea:focus {
            background: var(--input-bg);
            color: var(--text-color);
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(var(--primary-rgb), 0.25);
        }

        .note-actions button {
            flex: 1;
            min-width: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }

        .note-actions button i {
            font-size: 0.9rem;
        }

        [data-bs-theme="light"] .note-item {
            background: #ffffff;
            border: 1px solid #e0e0e0;
        }

        [data-bs-theme="light"] .note-text {
            color: #333333;
        }

        [data-bs-theme="light"] .note-timestamp {
            color: var(--primary-color);
        }

        [data-bs-theme="light"] #notesList::-webkit-scrollbar-track {
            background: #f0f0f0;
        }

        [data-bs-theme="dark"] .note-item {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
        }

        [data-bs-theme="dark"] .note-text {
            color: #e0e0e0;
        }

        [data-bs-theme="dark"] #notesList::-webkit-scrollbar-track {
            background: var(--card-bg);
        }

        /* Add styles for tasks list */
        #tasksList {
            max-height: 300px;
            overflow-y: auto;
            padding-right: 8px;
            margin-right: -8px;
            scrollbar-width: thin;
        }

        #tasksList::-webkit-scrollbar {
            width: 6px;
        }

        #tasksList::-webkit-scrollbar-track {
            background: var(--card-bg);
            border-radius: 10px;
        }

        #tasksList::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 10px;
        }

        #tasksList::-webkit-scrollbar-thumb:hover {
            background: var(--primary-hover-color);
        }

        .task-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            margin-bottom: 8px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            transition: transform 0.2s ease;
        }

        .task-item:hover {
            transform: translateX(5px);
        }

        .task-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .task-checkbox.checked {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }

        .task-checkbox.checked i {
            color: white;
            font-size: 12px;
        }

        .task-text {
            flex: 1;
            font-size: 0.95rem;
            color: var(--text-color);
            word-break: break-word;
            margin: 0;
            line-height: 1.4;
        }

        .task-text.completed {
            text-decoration: line-through;
            color: var(--text-muted);
        }

        .task-delete {
            color: var(--danger-color);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .task-delete:hover {
            background-color: rgba(var(--danger-rgb), 0.1);
        }

        [data-bs-theme="light"] .task-item {
            background: #ffffff;
            border: 1px solid #e0e0e0;
        }

        [data-bs-theme="light"] .task-text {
            color: #333333;
        }

        [data-bs-theme="light"] .task-text.completed {
            color: #888888;
        }

        [data-bs-theme="dark"] .task-item {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
        }

        [data-bs-theme="dark"] .task-text {
            color: #e0e0e0;
        }

        [data-bs-theme="dark"] .task-text.completed {
            color: #666666;
        }

        [data-bs-theme="dark"] #tasksList::-webkit-scrollbar-track {
            background: var(--card-bg);
        }

        [data-bs-theme="light"] #tasksList::-webkit-scrollbar-track {
            background: #f0f0f0;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg">
        <div class="container">
            <a class="navbar-brand" href="index.html">
                <i class="bi bi-book-half me-2"></i>Study Flow
            </a>
            <div class="nav-links">
                <a href="index.html" class="nav-link">
                    <i class="bi bi-house-door"></i>
                    Home
                </a>
            </div>
            <div class="theme-switch-wrapper ms-auto">
                <i class="bi bi-sun-fill theme-icon light-icon"></i>
                <div class="form-check form-switch ms-2 me-2">
                    <input class="form-check-input" type="checkbox" id="themeSwitch">
                </div>
                <i class="bi bi-moon-fill theme-icon dark-icon"></i>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <div class="row">
            <div class="col-lg-8">
                <div class="video-container">
                    <div id="player"></div>
                </div>
            </div>
            <div class="col-lg-4">
                <!-- Study Notes Section -->
                <div class="notes-section mb-4">
                    <h4>Study Notes</h4>
                    <div class="mb-3">
                        <div class="input-group">
                            <textarea class="form-control" id="noteInput" rows="3" placeholder="Write your study notes here..."></textarea>
                        </div>
                        <button class="btn btn-primary mt-2 w-100" id="addNoteBtn">
                            <i class="bi bi-plus-circle me-2"></i>Add Note
                        </button>
                    </div>
                    <div class="recording-controls">
                        <button class="btn btn-danger flex-grow-1" id="recordBtn">
                            <i class="bi bi-mic-fill"></i> Start Recording
                        </button>
                        <button class="btn btn-secondary flex-grow-1" id="stopBtn" disabled>
                            <i class="bi bi-stop-fill"></i> Stop
                        </button>
                    </div>
                    <div id="notesList" class="mt-4">
                        <!-- Notes will be displayed here -->
                    </div>
                </div>

                <!-- Today's Tasks Section -->
                <div class="tasks-section mb-4">
                    <h4><i class="bi bi-check2-square"></i> Today's Tasks</h4>
                    <div class="task-input-group mb-3">
                        <input type="text" class="form-control" id="taskInput" placeholder="Add a new task...">
                        <button class="btn btn-primary mt-2 w-100" id="addTaskBtn">
                            <i class="bi bi-plus-circle me-2"></i>Add Task
                        </button>
                    </div>
                    <div id="tasksList">
                        <!-- Tasks will be displayed here -->
                    </div>
                </div>

                <!-- Performance Section -->
                <div class="performance-section">
                    <h4><i class="bi bi-graph-up"></i> Your Progress</h4>
                    <div class="progress-stats">
                        <div class="stat-card">
                            <div class="stat-label">Video Progress</div>
                            <div class="progress">
                                <div class="progress-bar" id="videoProgress" role="progressbar" style="width: 0%"></div>
                            </div>
                            <div class="stat-value" id="videoProgressText">0%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Study Time Today</div>
                            <div class="stat-value" id="studyTimeToday">0 min</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Notes Created</div>
                            <div class="stat-value" id="notesCount">0</div>
                        </div>
                    </div>
                </div>

                <!-- Watch History Section -->
                <div class="watch-history-section mt-4">
                    <h4><i class="bi bi-clock-history"></i> Recently Watched</h4>
                    <div id="watchHistoryList" class="mt-3">
                        <!-- Watch history will be displayed here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
        import { getDatabase, ref, set, get } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js';
        import {
            saveVideoProgress,
            getVideoProgress,
            saveNotes,
            getNotes,
            saveTasks,
            getTasks,
            updateStudyTime,
            getStudyTime,
            markVideoCompleted,
            isVideoCompleted,
            addToWatchHistory,
            getLastSearch,
            getWatchHistory,
            setupRealtimeListeners
        } from './database.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyD33YiLLyTxlIycnHcArDKbgxvK_se27eA",
            authDomain: "studyflow-6ed25.firebaseapp.com",
            databaseURL: "https://studyflow-6ed25-default-rtdb.firebaseio.com",
            projectId: "studyflow-6ed25",
            storageBucket: "studyflow-6ed25.firebasestorage.app",
            messagingSenderId: "562903369542",
            appId: "1:562903369542:web:3f80ceb14d749870fc0747",
            measurementId: "G-TD7DS8YKSB"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);
        let currentUser = null;

        // YouTube player variables
        let player;
        let notes = [];
        let tasks = [];

        // Fix video ID parameter handling
        function getVideoId() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('v') || urlParams.get('id'); // Check both 'v' and 'id' parameters
        }

        // Initialize YouTube player
        async function initializePlayer() {
            const videoId = getVideoId();
            if (!videoId) {
                console.error('No video ID provided!');
                return;
            }

            if (!window.YT) {
                console.error('YouTube API not loaded');
                return;
            }

            try {
                window.player = new YT.Player('player', {
                    height: '360',
                    width: '640',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1,
                        'rel': 0,
                        'modestbranding': 1,
                        'controls': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange,
                        'onError': onPlayerError
                    }
                });
            } catch (error) {
                console.error('Error initializing player:', error);
            }
        }

        // YouTube API Ready callback
        window.onYouTubeIframeAPIReady = function() {
            if (currentUser) {
                initializePlayer();
            }
        };

        // Player Ready Event
        function onPlayerReady(event) {
            console.log('Player ready');
            document.getElementById('player').classList.add('loaded');
            loadSavedProgress();
        }

        // Load saved progress
        async function loadSavedProgress() {
            if (!currentUser || !window.player) return;

            const videoId = getVideoId();
            try {
                const progress = await getVideoProgress(currentUser.uid, videoId);
                if (progress && progress.currentTime) {
                    window.player.seekTo(progress.currentTime, true);
                    window.player.playVideo();
                    
                    // Update progress bar
                    const progressPercent = (progress.currentTime / progress.duration) * 100;
                    document.getElementById('videoProgress').style.width = `${progressPercent}%`;
                    document.getElementById('videoProgressText').textContent = `${Math.round(progressPercent)}%`;
                }
            } catch (error) {
                console.error('Error loading saved progress:', error);
            }
        }

        // Authentication state change handler
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                await initTheme();
                
                // Initialize player if YouTube API is ready
                if (window.YT && window.YT.Player) {
                    await initializePlayer();
                }

                // Load user data
                const videoId = getVideoId();
                if (videoId) {
                    try {
                        // Load notes specifically for this video
                        const notesData = await getNotes(user.uid, videoId);
                        notes = Array.isArray(notesData) ? notesData : [];
                        displayNotes();
                        
                        // Update notes count
                        document.getElementById('notesCount').textContent = notes.length.toString();

                        // Update tasks
                        const tasksData = await getTasks(user.uid);
                        tasks = tasksData || [];
                        displayTasks();

                        // Setup real-time listeners
                        setupRealtimeListeners(user.uid, {
                            onNotesUpdate: (updatedNotes) => {
                                if (updatedNotes[videoId]) {
                                    notes = updatedNotes[videoId];
                                    displayNotes();
                                }
                            },
                            onTasksUpdate: (updatedTasks) => {
                                tasks = updatedTasks;
                                displayTasks();
                            },
                            onPerformanceUpdate: (performance) => {
                                updatePerformanceDisplay(performance);
                            }
                        });

                        // Start tracking performance
                startPerformanceTracking();
                        
                        // Add to watch history
                        addToWatchHistoryAndLoadVideo();

                    } catch (error) {
                        console.error('Error loading user data:', error);
                    }
                }
            } else {
                window.location.href = 'signin.html';
            }
        });

        // Theme switching functionality
        const themeSwitch = document.getElementById('themeSwitch');

        async function initTheme() {
            if (!currentUser) return;
            
            try {
                const settingsRef = ref(db, `users/${currentUser.uid}/settings`);
                const snapshot = await get(settingsRef);
                const settings = snapshot.val() || {};
                const theme = settings.theme || 'light';
                
                document.documentElement.setAttribute('data-bs-theme', theme);
                themeSwitch.checked = theme === 'dark';
            } catch (error) {
                console.error('Error initializing theme:', error);
                document.documentElement.setAttribute('data-bs-theme', 'light');
                themeSwitch.checked = false;
            }
        }

        async function toggleTheme() {
            if (!currentUser) return;
            
            try {
                const currentTheme = document.documentElement.getAttribute('data-bs-theme');
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                
                // Update theme immediately
                document.documentElement.setAttribute('data-bs-theme', newTheme);
                
                // Save to Firebase
                const settingsRef = ref(db, `users/${currentUser.uid}/settings`);
                const snapshot = await get(settingsRef);
                const settings = snapshot.val() || {};
                settings.theme = newTheme;
                await set(settingsRef, settings);
            } catch (error) {
                console.error('Error toggling theme:', error);
            }
        }

        // Add theme switch event listener
        themeSwitch.addEventListener('change', toggleTheme);

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.ENDED) {
                // Video ended
                document.getElementById('videoProgress').style.width = '100%';
                document.getElementById('videoProgressText').textContent = '100%';
                
                // Mark video as completed
                const videoId = getVideoId();
                markVideoCompleted(currentUser.uid, videoId);
            } else if (event.data === YT.PlayerState.PLAYING) {
                // Video is playing
                startProgressTracking();
            }
        }

        function onPlayerError(event) {
            console.error('YouTube Player Error:', event.data);
            alert('Error loading video. Please check if the video ID is correct and the video is available.');
        }

        // Update progress every second
        let progressInterval;
        function startProgressTracking() {
            if (progressInterval) {
                clearInterval(progressInterval);
            }
            progressInterval = setInterval(updateProgress, 1000);
        }

        async function updateProgress() {
            if (player && player.getCurrentTime && player.getDuration) {
                const currentTime = player.getCurrentTime();
                const duration = player.getDuration();
                const progress = (currentTime / duration) * 100;
                
                document.getElementById('videoProgress').style.width = `${progress}%`;
                document.getElementById('videoProgressText').textContent = `${Math.round(progress)}%`;

                // Save progress
                const videoId = getVideoId();
                const progressData = {
                    currentTime: currentTime,
                    duration: duration,
                    progress: progress
                };
                await saveVideoProgress(currentUser.uid, videoId, progressData);
            }
        }

        // Notes functionality
        async function addNote() {
            const noteText = document.getElementById('noteInput').value.trim();
            if (!noteText || !currentUser || !window.player) return;
            
            try {
                const timestamp = window.player.getCurrentTime();
                const videoId = getVideoId();
                
                const note = {
                    id: Date.now().toString(),
                    text: noteText,
                    timestamp: timestamp,
                    formattedTime: formatTime(timestamp),
                    createdAt: new Date().toISOString()
                };
                
                // Initialize notes array if undefined
                if (!Array.isArray(notes)) {
                    notes = [];
                }
                
                // Add new note
                notes.push(note);
                
                // Clear input
                document.getElementById('noteInput').value = '';
                
                // Save to Firebase
                await saveNotes(currentUser.uid, videoId, notes);
                
                // Update display
                displayNotes();
                
                // Update notes count
                document.getElementById('notesCount').textContent = notes.length.toString();
                
                console.log('Note added successfully:', note);
            } catch (error) {
                console.error('Error adding note:', error);
                alert('Failed to add note. Please try again.');
            }
        }

        function displayNotes() {
            const notesList = document.getElementById('notesList');
            if (!notesList || !Array.isArray(notes)) return;
            
            notesList.innerHTML = '';
            
            // Sort notes by timestamp
            const sortedNotes = [...notes].sort((a, b) => a.timestamp - b.timestamp);
            
            sortedNotes.forEach(note => {
                const noteElement = document.createElement('div');
                noteElement.className = 'note-item';
                
                let audioPlayer = '';
                if (note.audioData) {
                    audioPlayer = `
                        <audio controls class="mt-2 w-100">
                            <source src="${note.audioData}" type="audio/wav">
                            Your browser does not support the audio element.
                        </audio>
                    `;
                }

                if (editingNoteId === note.id) {
                    // Show edit form
                    noteElement.innerHTML = `
                        <div class="note-timestamp">${note.formattedTime}</div>
                        <div class="edit-note-form">
                            <textarea class="form-control mb-2" id="editNoteText">${note.text}</textarea>
                            <div class="d-flex gap-2">
                                <button class="btn btn-sm btn-success" onclick="saveEditedNote('${note.id}')">
                                    <i class="bi bi-check-lg"></i> Save
                                </button>
                                <button class="btn btn-sm btn-secondary" onclick="cancelEdit()">
                                    <i class="bi bi-x-lg"></i> Cancel
                                </button>
                            </div>
                        </div>
                    `;
                } else {
                    // Show normal note view
                    noteElement.innerHTML = `
                        <div class="note-timestamp" onclick="seekToTimestamp(${note.timestamp})">
                            ${note.formattedTime}
                        </div>
                        <div class="note-text">${note.text}</div>
                        ${audioPlayer}
                        <div class="note-actions d-flex gap-2 mt-2">
                            <button class="btn btn-sm btn-primary" onclick="seekToTimestamp(${note.timestamp})">
                                <i class="bi bi-play-fill"></i> Go to timestamp
                            </button>
                            <button class="btn btn-sm btn-warning" onclick="editNote('${note.id}')">
                                <i class="bi bi-pencil"></i> Edit
                            </button>
                            <button class="btn btn-sm btn-danger" onclick="deleteNote('${note.id}')">
                                <i class="bi bi-trash"></i> Delete
                            </button>
                        </div>
                    `;
                }
                notesList.appendChild(noteElement);
            });
        }

        async function deleteNote(noteId) {
            if (!currentUser || !Array.isArray(notes)) return;

            try {
                const videoId = getVideoId();
                notes = notes.filter(note => note.id !== noteId);
                
                // Save updated notes to Firebase
                await saveNotes(currentUser.uid, videoId, notes);
                
                // Update display
        displayNotes();
                
                // Update notes count
                document.getElementById('notesCount').textContent = notes.length.toString();
                
                console.log('Note deleted successfully:', noteId);
            } catch (error) {
                console.error('Error deleting note:', error);
                alert('Failed to delete note. Please try again.');
            }
        }

        // Tasks functionality
        async function addTask(text) {
            const task = {
                id: Date.now(),
                text: text,
                completed: false,
                date: new Date().toDateString()
            };
            
            tasks.push(task);
            await saveTasks(currentUser.uid, tasks);
            displayTasks();
            document.getElementById('taskInput').value = '';
        }

        async function toggleTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                task.completed = !task.completed;
                await saveTasks(currentUser.uid, tasks);
                displayTasks();
            }
        }

        async function deleteTask(taskId) {
            tasks = tasks.filter(t => t.id !== taskId);
            await saveTasks(currentUser.uid, tasks);
            displayTasks();
        }

        function displayTasks() {
            const tasksList = document.getElementById('tasksList');
            const todayTasks = tasks.filter(task => task.date === new Date().toDateString());
            
            tasksList.innerHTML = '';
            todayTasks.forEach(task => {
                const taskElement = document.createElement('div');
                taskElement.className = 'task-item';
                taskElement.innerHTML = `
                    <div class="task-checkbox ${task.completed ? 'checked' : ''}" onclick="toggleTask(${task.id})">
                        ${task.completed ? '<i class="bi bi-check"></i>' : ''}
                    </div>
                    <div class="task-text ${task.completed ? 'completed' : ''}">${task.text}</div>
                    <i class="bi bi-trash task-delete" onclick="deleteTask(${task.id})"></i>
                `;
                tasksList.appendChild(taskElement);
            });
        }

        // Performance tracking
        let startTime = Date.now();
        let studyTimeToday = 0;

        async function startPerformanceTracking() {
            studyTimeToday = await getStudyTime(currentUser.uid);
            document.getElementById('studyTimeToday').textContent = `${studyTimeToday} min`;

            // Update performance metrics every minute
            setInterval(async () => {
                studyTimeToday = await updateStudyTime(currentUser.uid, 1);
                document.getElementById('studyTimeToday').textContent = `${studyTimeToday} min`;

                // Update notes count
                const videoId = getVideoId();
                document.getElementById('notesCount').textContent = notes.length.toString();
            }, 60000);
        }

        // Add to watch history
        async function addToWatchHistoryAndLoadVideo() {
            const videoId = getVideoId();
            const lastSearch = await getLastSearch(currentUser.uid);
            const video = lastSearch?.results?.find(v => v.id.videoId === videoId);
            
            if (video) {
                await addToWatchHistory(currentUser.uid, video);
                await displayWatchHistory();
            }
        }

        // Display watch history
        async function displayWatchHistory() {
            const watchHistoryList = document.getElementById('watchHistoryList');
            const watchHistory = await getWatchHistory(currentUser.uid);
            
            if (!watchHistory || watchHistory.length === 0) {
                watchHistoryList.innerHTML = `
                    <div class="text-center text-muted">
                        <p>No watch history yet</p>
                    </div>
                `;
                return;
            }
            
            // Display only the last 5 watched videos
            const recentVideos = watchHistory.slice(0, 5);
            watchHistoryList.innerHTML = recentVideos.map(video => `
                <div class="watch-history-item mb-3">
                    <div class="d-flex align-items-center">
                        <img src="${video.snippet.thumbnails.default.url}" 
                             alt="${video.snippet.title}" 
                             class="watch-history-thumbnail me-2">
                        <div class="watch-history-info flex-grow-1">
                            <h6 class="mb-1">${video.snippet.title}</h6>
                            <small class="text-muted">Watched on ${new Date(video.watchedAt).toLocaleDateString()}</small>
                        </div>
                        <a href="player.html?id=${video.id.videoId}" class="btn btn-sm btn-primary">
                            <i class="bi bi-play-fill"></i>
                        </a>
                    </div>
                </div>
            `).join('');
        }

        // Helper function to format time
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            seconds = Math.floor(seconds % 60);
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Make functions globally available
        window.addNote = addNote;
        window.deleteNote = deleteNote;
        window.editNote = editNote;
        window.saveEditedNote = saveEditedNote;
        window.cancelEdit = cancelEdit;
        window.addTask = addTask;
        window.toggleTask = toggleTask;
        window.deleteTask = deleteTask;
        window.seekToTimestamp = seekToTimestamp;
        window.startRecording = startRecording;
        window.stopRecording = stopRecording;

        // Voice Recording functionality
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStream = null;

        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopBtn');

        async function startRecording() {
            try {
                if (isRecording) {
                    console.log('Already recording');
                    return;
                }

                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true,
                    video: false
                });
                
                recordingStream = stream;
                audioChunks = [];
                mediaRecorder = new MediaRecorder(stream);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                    audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    try {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        const timestamp = window.player.getCurrentTime();
                    
                    // Convert audio to base64
                    const reader = new FileReader();
                    reader.readAsDataURL(audioBlob);
                    reader.onloadend = async () => {
                            try {
                        const base64Audio = reader.result;
                        
                        // Create note with audio
                        const note = {
                                    id: Date.now().toString(),
                            text: 'ðŸŽ¤ Voice Note',
                            timestamp: timestamp,
                            formattedTime: formatTime(timestamp),
                                    audioData: base64Audio,
                                    createdAt: new Date().toISOString()
                        };
                                
                                // Initialize notes array if undefined
                                if (!Array.isArray(notes)) {
                                    notes = [];
                                }
                        
                        notes.push(note);
                        
                        // Save notes
                                const videoId = getVideoId();
                        await saveNotes(currentUser.uid, videoId, notes);
                        
                                // Update display and count
                        displayNotes();
                                document.getElementById('notesCount').textContent = notes.length.toString();
                                
                                console.log('Voice note saved successfully');
                            } catch (error) {
                                console.error('Error saving voice note:', error);
                                alert('Failed to save voice note. Please try again.');
                            }
                        };
                        
                        // Reset recording state
                    audioChunks = [];
                        const recordBtn = document.getElementById('recordBtn');
                    recordBtn.innerHTML = '<i class="bi bi-mic-fill"></i> Start Recording';
                    recordBtn.classList.remove('btn-danger');
                    recordBtn.classList.add('btn-primary');
                        document.getElementById('stopBtn').disabled = true;
                        
                        // Stop all tracks
                        if (recordingStream) {
                            recordingStream.getTracks().forEach(track => track.stop());
                            recordingStream = null;
                        }
                    } catch (error) {
                        console.error('Error processing recording:', error);
                        alert('Error processing recording. Please try again.');
                    }
                };

                mediaRecorder.start();
                isRecording = true;
                
                const recordBtn = document.getElementById('recordBtn');
                recordBtn.innerHTML = '<i class="bi bi-record-circle"></i> Recording...';
                recordBtn.classList.remove('btn-primary');
                recordBtn.classList.add('btn-danger');
                document.getElementById('stopBtn').disabled = false;
                
                console.log('Recording started');
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Error accessing microphone. Please ensure you have granted microphone permissions and try again.');
                resetRecordingState();
            }
        }

        function stopRecording() {
            try {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                    document.getElementById('stopBtn').disabled = true;
                    
                    // Stop all tracks
                    if (recordingStream) {
                        recordingStream.getTracks().forEach(track => track.stop());
                        recordingStream = null;
                    }
                    
                    console.log('Recording stopped');
                }
            } catch (error) {
                console.error('Error stopping recording:', error);
                alert('Error stopping recording. Please try again.');
                resetRecordingState();
            }
        }

        function resetRecordingState() {
            isRecording = false;
            mediaRecorder = null;
            audioChunks = [];
            
            if (recordingStream) {
                recordingStream.getTracks().forEach(track => track.stop());
                recordingStream = null;
            }
            
            const recordBtn = document.getElementById('recordBtn');
            recordBtn.innerHTML = '<i class="bi bi-mic-fill"></i> Start Recording';
            recordBtn.classList.remove('btn-danger');
            recordBtn.classList.add('btn-primary');
            document.getElementById('stopBtn').disabled = true;
        }

        // Add recording event listeners
        document.addEventListener('DOMContentLoaded', () => {
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');
            const addNoteBtn = document.getElementById('addNoteBtn');
            const addTaskBtn = document.getElementById('addTaskBtn');
            const noteInput = document.getElementById('noteInput');
            const taskInput = document.getElementById('taskInput');
            
            if (recordBtn) {
                recordBtn.addEventListener('click', () => {
                    if (!isRecording) {
                        startRecording();
                    }
                });
            }

            if (stopBtn) {
                stopBtn.addEventListener('click', stopRecording);
            }

            // Add note button click handler
            if (addNoteBtn) {
                addNoteBtn.addEventListener('click', addNote);
            }

            // Add note on Enter key press (Shift+Enter for new line)
            if (noteInput) {
                noteInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        addNote();
                    }
                });
            }

            // Add task button click handler
            if (addTaskBtn) {
                addTaskBtn.addEventListener('click', () => {
                    const taskText = taskInput.value.trim();
                    if (taskText) {
                        addTask(taskText);
                    }
                });
            }

            // Add task on Enter key press
            if (taskInput) {
                taskInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const taskText = taskInput.value.trim();
                        if (taskText) {
                            addTask(taskText);
                        }
                    }
                });
            }
        });

        // Helper function to update study time display
        function updateStudyTimeDisplay(time) {
            const hours = Math.floor(time / 3600);
            const minutes = Math.floor((time % 3600) / 60);
            document.getElementById('studyTimeToday').textContent = 
                `${hours}h ${minutes}m`;
        }

        // Function to seek to timestamp
        function seekToTimestamp(timestamp) {
            if (window.player && window.player.seekTo) {
                window.player.seekTo(parseFloat(timestamp));
            }
        }

        // Add editingNoteId variable to track which note is being edited
        let editingNoteId = null;

        // Function to start editing a note
        function editNote(noteId) {
            editingNoteId = noteId;
            displayNotes();
        }

        // Function to save edited note
        async function saveEditedNote(noteId) {
            if (!currentUser) return;

            try {
                const editedText = document.getElementById('editNoteText').value.trim();
                if (!editedText) return;

                const noteIndex = notes.findIndex(note => note.id === noteId);
                if (noteIndex === -1) return;

                // Update the note text while preserving other properties
                notes[noteIndex] = {
                    ...notes[noteIndex],
                    text: editedText,
                    lastEdited: new Date().toISOString()
                };

                // Save to Firebase
                const videoId = getVideoId();
                await saveNotes(currentUser.uid, videoId, notes);

                // Reset editing state and refresh display
                editingNoteId = null;
                displayNotes();

                console.log('Note edited successfully:', noteId);
            } catch (error) {
                console.error('Error editing note:', error);
                alert('Failed to edit note. Please try again.');
            }
        }

        // Function to cancel editing
        function cancelEdit() {
            editingNoteId = null;
            displayNotes();
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script type="module" src="themeManager.js"></script>
</body>
</html> 